<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CategoryCorrectness" xml:space="preserve">
    <value>Correctness</value>
  </data>
  <data name="CategoryPerformance" xml:space="preserve">
    <value>Performance</value>
  </data>
  <data name="CategoryTypeSafety" xml:space="preserve">
    <value>Type Safety</value>
  </data>
  <data name="EmptyUnityMessageCodeFixTitle" xml:space="preserve">
    <value>Remove empty Unity message</value>
  </data>
  <data name="EmptyUnityMessageDiagnosticDescription" xml:space="preserve">
    <value>Unity messages are called by the runtime even if they're empty. Remove them to avoid unnecessary processing.</value>
  </data>
  <data name="EmptyUnityMessageDiagnosticMessageFormat" xml:space="preserve">
    <value>The Unity message "{0}" is empty.</value>
  </data>
  <data name="EmptyUnityMessageDiagnosticTitle" xml:space="preserve">
    <value>Empty Unity message</value>
  </data>
  <data name="TagComparisonCodeFixTitle" xml:space="preserve">
    <value>Use CompareTag method</value>
  </data>
  <data name="TagComparisonDiagnosticDescription" xml:space="preserve">
    <value>Comparing tags using == is slower than using the built-in CompareTag method.</value>
  </data>
  <data name="TagComparisonDiagnosticMessageFormat" xml:space="preserve">
    <value>Comparing tags using == is inefficient.</value>
  </data>
  <data name="TagComparisonDiagnosticTitle" xml:space="preserve">
    <value>Inefficient tag comparison</value>
  </data>
  <data name="NonGenericGetComponentCodeFixTitle" xml:space="preserve">
    <value>Use the generic form of GetComponent</value>
  </data>
  <data name="NonGenericGetComponentDiagnosticDescription" xml:space="preserve">
    <value>Usage of the generic form of GetComponent is preferred for type safety.</value>
  </data>
  <data name="NonGenericGetComponentDiagnosticMessageFormat" xml:space="preserve">
    <value>Method "{0}" has a preferred generic overload.</value>
  </data>
  <data name="NonGenericGetComponentDiagnosticTitle" xml:space="preserve">
    <value>Usage of non generic GetComponent</value>
  </data>
  <data name="UpdateWithoutFixedDeltaTimeCodeFixTitle" xml:space="preserve">
    <value>Use Time.deltaTime</value>
  </data>
  <data name="UpdateWithoutFixedDeltaTimeDiagnosticDescription" xml:space="preserve">
    <value>Update is dependent on the frame rate. Use Time.deltaTime instead of Time.fixedDeltaTime.</value>
  </data>
  <data name="UpdateWithoutFixedDeltaTimeDiagnosticMessageFormat" xml:space="preserve">
    <value>Update should use Time.deltaTime.</value>
  </data>
  <data name="UpdateWithoutFixedDeltaTimeDiagnosticTitle" xml:space="preserve">
    <value>Time.fixedDeltaTime used with Update</value>
  </data>
  <data name="FixedUpdateWithoutDeltaTimeCodeFixTitle" xml:space="preserve">
    <value>Use Time.fixedDeltaTime</value>
  </data>
  <data name="FixedUpdateWithoutDeltaTimeDiagnosticDescription" xml:space="preserve">
    <value>FixedUpdate is independent of the frame rate. Use Time.fixedDeltaTime instead of Time.deltaTime.</value>
  </data>
  <data name="FixedUpdateWithoutDeltaTimeDiagnosticMessageFormat" xml:space="preserve">
    <value>FixedUpdate should use Time.fixedDeltaTime.</value>
  </data>
  <data name="FixedUpdateWithoutDeltaTimeDiagnosticTitle" xml:space="preserve">
    <value>Time.deltaTime used with FixedUpdate</value>
  </data>
  <data name="InitializeOnLoadStaticCtorCodeFixTitle" xml:space="preserve">
    <value>Add static constructor</value>
  </data>
  <data name="InitializeOnLoadStaticCtorDiagnosticDescription" xml:space="preserve">
    <value>Provide a static constructor when applying the InitializeOnLoad attribute to a class. This will call it when the editor launches.</value>
  </data>
  <data name="InitializeOnLoadStaticCtorDiagnosticMessageFormat" xml:space="preserve">
    <value>The class "{0}" tagged with the InitializeOnLoad attribute is missing a static conductor.</value>
  </data>
  <data name="InitializeOnLoadStaticCtorDiagnosticTitle" xml:space="preserve">
    <value>Missing static constructor with InitializeOnLoad</value>
  </data>
  <data name="MessageSignatureCodeFixTitle" xml:space="preserve">
    <value>Fix message signature</value>
  </data>
  <data name="MessageSignatureDiagnosticDescription" xml:space="preserve">
    <value>This Unity message uses an incorrect method signature.</value>
  </data>
  <data name="MessageSignatureDiagnosticMessageFormat" xml:space="preserve">
    <value>The Unity message "{0}" has an incorrect signature.</value>
  </data>
  <data name="MessageSignatureDiagnosticTitle" xml:space="preserve">
    <value>Incorrect message signature</value>
  </data>
  <data name="UnityObjectNullCoalescingCodeFixTitle" xml:space="preserve">
    <value>Use null comparison</value>
  </data>
  <data name="UnityObjectNullCoalescingDiagnosticDescription" xml:space="preserve">
    <value>Unity overrides the null comparison operator for Unity objects, which is incompatible with null coalescing.</value>
  </data>
  <data name="UnityObjectNullCoalescingDiagnosticMessageFormat" xml:space="preserve">
    <value>Unity objects should not use null coalescing.</value>
  </data>
  <data name="UnityObjectNullCoalescingDiagnosticTitle" xml:space="preserve">
    <value>Null coalescing on Unity objects</value>
  </data>
  <data name="UnityObjectNullPropagationCodeFixTitle" xml:space="preserve">
    <value>Use null comparison</value>
  </data>
  <data name="UnityObjectNullPropagationDiagnosticDescription" xml:space="preserve">
    <value>Unity overrides the null comparison operator for Unity objects, which is incompatible with null propagation.</value>
  </data>
  <data name="UnityObjectNullPropagationDiagnosticMessageFormat" xml:space="preserve">
    <value>Unity objects should not use null propagation.</value>
  </data>
  <data name="UnityObjectNullPropagationDiagnosticTitle" xml:space="preserve">
    <value>Null propagation on Unity objects</value>
  </data>
  <data name="UnityObjectNullCoalescingSuppressorJustification" xml:space="preserve">
    <value>Unity objects should not use null coalescing.</value>
  </data>
  <data name="UnityObjectNullPropagationSuppressorJustification" xml:space="preserve">
    <value>Unity objects should not use null propagation.</value>
  </data>
  <data name="CreateMonoBehaviourInstanceCodeFixTitle" xml:space="preserve">
    <value>Use gameObject.AddComponent()</value>
  </data>
  <data name="CreateMonoBehaviourInstanceDiagnosticDescription" xml:space="preserve">
    <value>Use AddComponent() to create MonoBehaviours. A MonoBehaviour component needs to be attached to a GameObject.</value>
  </data>
  <data name="CreateMonoBehaviourInstanceDiagnosticMessageFormat" xml:space="preserve">
    <value>MonoBehaviour "{0}" should not be instantiated directly.</value>
  </data>
  <data name="CreateMonoBehaviourInstanceDiagnosticTitle" xml:space="preserve">
    <value>MonoBehaviour instance creation</value>
  </data>
  <data name="CreateScriptableObjectInstanceCodeFixTitle" xml:space="preserve">
    <value>Use ScriptableObject.CreateInstance()</value>
  </data>
  <data name="CreateScriptableObjectInstanceDiagnosticDescription" xml:space="preserve">
    <value>Use CreateInstance() to create a ScriptableObject. To handle Unity message methods, the Unity engine needs to create the ScriptableObject.</value>
  </data>
  <data name="CreateScriptableObjectInstanceDiagnosticMessageFormat" xml:space="preserve">
    <value>ScriptableObject "{0}" should not be instantiated directly.</value>
  </data>
  <data name="CreateScriptableObjectInstanceDiagnosticTitle" xml:space="preserve">
    <value>ScriptableObject instance creation</value>
  </data>
  <data name="UnusedMessageSuppressorJustification" xml:space="preserve">
    <value>The Unity runtime invokes Unity messages.</value>
  </data>
  <data name="ReadonlySerializeFieldSuppressorJustification" xml:space="preserve">
    <value>Don't set fields with a SerializeField or SerializeReference attributes to read-only.</value>
  </data>
  <data name="UnusedSerializeFieldSuppressorJustification" xml:space="preserve">
    <value>Don't flag private fields with a SerializeField or SerializeReference attribute as unused.</value>
  </data>
  <data name="NeverAssignedSerializeFieldSuppressorJustification" xml:space="preserve">
    <value>Don't flag fields with a SerializeField or SerializeReference attribute as never assigned.</value>
  </data>
  <data name="UnusedMethodSuppressorJustification" xml:space="preserve">
    <value>Don't flag private methods used with Invoke/InvokeRepeating or StartCoroutine/StopCoroutine as unused.</value>
  </data>
  <data name="UnusedCoroutineReturnValueCodeFixTitle" xml:space="preserve">
    <value>Use StartCoroutine()</value>
  </data>
  <data name="UnusedCoroutineReturnValueDiagnosticDescription" xml:space="preserve">
    <value>Use StartCoroutine() to start a coroutine. Calling the coroutine method directly will result in the coroutine never being executed.</value>
  </data>
  <data name="UnusedCoroutineReturnValueDiagnosticMessageFormat" xml:space="preserve">
    <value>Coroutine {0} should be called using StartCoroutine().</value>
  </data>
  <data name="UnusedCoroutineReturnValueDiagnosticTitle" xml:space="preserve">
    <value>Unused Unity Coroutine</value>
  </data>
  <data name="UnusedMethodContextMenuSuppressorJustification" xml:space="preserve">
    <value>Don't flag methods with the ContextMenu attribute or referenced by a field with the ContextMenuItem attribute as unused.</value>
  </data>
  <data name="ReadonlyContextMenuItemJustification" xml:space="preserve">
    <value>Don't set fields with a ContextMenuItem attribute as readonly.</value>
  </data>
  <data name="UnusedContextMenuItemJustification" xml:space="preserve">
    <value>Don't flag fields with a ContextMenuItem attribute as unused.</value>
  </data>
  <data name="ImproperSerializeFieldCodeFixTitle" xml:space="preserve">
    <value>Remove SerializeField attribute</value>
  </data>
  <data name="ImproperSerializeFieldDiagnosticDescription" xml:space="preserve">
    <value>SerializeField attribute does not work on properties, and are unnecessary for public fields</value>
  </data>
  <data name="ImproperSerializeFieldDiagnosticMessageFormat" xml:space="preserve">
    <value>SerializeField attribute is invalid or redundant for property or field(s): {0}</value>
    <comment>{0} is a list of identifiers declared with a SerializeField attribute</comment>
  </data>
  <data name="ImproperSerializeFieldDiagnosticTitle" xml:space="preserve">
    <value>Remove invalid SerializeField attribute</value>
  </data>
</root>
